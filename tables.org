#+TITLE: Datomic Table Structure
* SQL

	SQL is built on relational algebra.

	A table is a function from the primary key into the space defined by
	the columns.

	Example:

	| ID | Size | Shape    | Colour  | Description        |
	|----+------+----------+---------+--------------------|
	|  1 |    4 | square   | #00A2FF | "Kind of blockish" |
	|  2 |    3 | oblong   | #777777 | "Not quite round"  |
	|  3 |    7 | triangle | #FFFFFF | "Pointy!"          |
	|    |      |          |         |                    |
	...

	This table maps IDs into the space of (size, shape, colour, description).

	At the end of the day, it's just a function!

* Datomic
** EAV
	 By contrast, in Datomic all functions have "simple" ranges.

	 In other words, tables only have one variable column.

	 | ID | Size |
	 |----+------|
	 |  1 |    4 |
	 |  2 |    3 |
	 |  3 |    7 |

	 Which means that we need one table per data attribute.

	 | ID | Shape    |
	 |----+----------|
	 |  1 | square   |
	 |  2 | oblong   |
	 |  3 | triangle |

	 ...

	 This is the basis of RDF and is sometimes called a schema in Sixth
	 Normal Form, but we're not going to talk about that.

** Datoms
	 Atomic Facts (data) are called datoms in Datomic and they're
	 actually a little more complicated.

	 Datoms are tuples of the form [E A V Tx Op]

	 E: an entity ID (just like a primary key in sql).

	 A: an attribute (name of a column).

	 V: the value of the attribute for this entity.

	 Tx: the transaction during which this datom was added to the DB.

	 Op: is this an assertion that the fact is true, or false?

** Tx Log

	 So we can see that our table analogy was a slight lie.

	 It turns out to be easier to think about a Datomic DB in terms of
	 the log, or list of all datoms seen so far.

	 The first table could have been derived from this log:

	 | E | A       | V         | Tx | Op    |
	 |---+---------+-----------+----+-------|
	 | 1 | :size   | 4         |  1 | true  |
	 | 1 | :shape  | :square   |  1 | true  |
	 | 1 | :colour | "#00A2FF" |  1 | true  |
	 | 2 | :size   | 5         |  2 | true  |
	 | 2 | :shape  | :oblong   |  2 | true  |
	 | 2 | :colour | "#777777  |  2 | true  |
	 | 3 | :size   | 7         |  3 | true  |
	 | 3 | :shape  | :triangle |  3 | true  |
	 | 3 | :colour | "#FFFFFF" |  3 | true  |
	 | 2 | :size   | 3         |  4 | true  |
	 | 2 | :size   | 5         |  4 | false |

	 Note the last Tx which retracts the previous :size of entity 2 and
	 replaces it.
** Schema
	 Each attribute is itself an entity. A schema in Datomic is just the
	 data description of those attribute entities.

	 A typical attribute might look like this:

	 #+BEGIN_SRC clojure

	 {:db/ident       :size
		:db/doc         "The size of the thing"
		:db/cardinality :db.cardinality/one
		:db/isComponent true
		:db/valueType   :db.type/long}

	 #+END_SRC

	 Datomic provides basic types (long, double, string, keyword, date, ...) but
	 can't store arbitrary clojure data (except as a string).

	 Let's fix that and write a schema for the Clojure AST, otherwise know as
	 S-expressions (plus data literals).
** Datalog
*** Description
		The query language that Datomic uses is called Datalog.

		Datalog is a subset of Prolog, but unlike full Prolog, a Datalog query on a
		finite domain is guaranteed to terminate, which is a good property for a
		query language.

		Also unlike Prolog, the order of statements in Datalog doesn't effect whether
		the query will terminate or not (since it will), but the order does have a
		huge impact on performance.

		However, Datalog is not Turing complete. In particular, it can't express
		negation.

		Datomic extends datalog by allowing you to add arbitrary clojure predicates
		to your queries, including not.

		In theory this could cause a query to never terminate, but there are
		timeouts.
*** Use
		Remember that data is stored in triples [1072 :food/likes "apples"]

		Query statements are also triples of the form [?who :food/likes "apples"]
		where ?who in this case is a variable that the query engine will bind to any
		matching datoms in the DB.

		This act of binding is called unification.

		Multiple queries are interpreted and conjuction, so the query

		[[?who :food/likes "apples"]
		 [?whoelse :person/likes ?who]]

		will bind ?who and ?whoelse to all pairs of people where one liked apples,
		and the other likes them.

		This works better with real examples.
** Time
	 Time is a first class entity in Datomic. Every datom contains the time at
	 which it was first perceived by the transactor.

	 This means that even though the value of a datom can change over time, the
	 value *now* will always be there if you look back to this point in time.

	 This is a much lower level of immutability than Clojure uses as a whole. In
	 fact it looks a lot like standard, mutable, place-oriented programming. And
	 it is.

	 The key difference is that although the values of things in a given place
	 change over time, the value of a given place at a given time is permanent.

	 Space-time addresses are unique.

	 This gives the performance benefit of mutability, without ever losing data
	 (or even clobbering it if you're careful).
** Indicies
	 Since everything is stored as a triple, there are only 6 possible
	 indicies. Of these, Datomic only makes 4, because frankly the others aren't
	 useful.

	 It's best to think about the indicies as edges in a graph that you can
	 quickly traverse to get from one piece of information to another.

	 The indicies are:

	 EAVT: Entity -> Attribute -> Value | I.E. lookup

	 VAET: (only on attributes of type ref, we don't want to index primitives).

	 AEVT: This index provides column search in a traditional DB

	 AVET: This index is expensive to maintain, and so isn't enabled by default.
